---
title: 'Assignment 1: NY Tree Census, 2005-2015'
author: "Alfredo Rojas"
date: "2/2/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Explore Tree Census data for 2005

```{r library results = "hide", message = FALSE}

library(tidyverse)
library(sf)
path_to_file = file.path("..", "data", "ny_trees2005.csv")
tree_2005 = path_to_file %>% read_csv()
```

## Explore data

Clean up the data using `group_by()` and `summarise()`. 

```{r clean}
head(tree_2005)

byBoro = tree_2005 %>%
  count(nta_name, boroname, spc_common, status, sort = TRUE)

head(byBoro, n = 10)
```

Let's visualize

```{r visual}

byBoro %>% ggplot() +
  geom_bar(aes(x = boroname, fill = status), position = "dodge") +
  coord_flip()
```

We can plot trees individually, but it takes a very long time. Probably because we have greater than 250,000 observations (lat/long points). Maybe this is not such a great idea. 

```{r visual2}
library(tmap)

# get location data
treeLocs = tree_2005 %>%
  select(OBJECTID, spc_common, nta, nta_name, boroname, latitude, longitude) %>%
  filter(boroname != 5) 

# get tree coordinates
tree_coord = unique(treeLocs[,c("latitude", "longitude")]) %>%
  rename(Longitude = longitude, Latitude = latitude)

# see how many unique object ids there are. 
treeLocs$OBJECTID %>%
  unique() %>%
  length()

# get amount of trees per NTA code
tree_num = treeLocs %>%
  group_by(nta) %>%
  summarise(num = n())

# set points with WGS1984 coordinate system
coord_proj = tree_coord %>% 
  st_as_sf(coords = c("Longitude", "Latitude"), crs = "+init=epsg:4326") 

path_to_file2 = file.path("..", "data", "nynta_19d", "nynta.shp")

ny = st_read(
  dsn = path_to_file2)

ny2 = ny %>% st_transform(crs = 4326)
st_crs(ny2)

tm_shape(ny) +
  tm_fill() +
  tm_borders() 

ny_tree = left_join(ny2, tree_num, by = c("NTACode" = "nta")) %>%
  mutate(normalized = scale(num, center = FALSE))


plot(st_geometry(ny_tree), col = ny_tree$normalized)

m1 = ggplot(ny_tree) + 
  geom_sf(aes(fill = normalized))

m2 = m1 + geom_polygon(color = "gray90", size = 0.05) + coord_equal()

m3 = m2 + scale_fill_brewer(palette = "Greens")
m3
m1
```


### notes

-Distribution of Income by borough. . . 

Positives: Narrative, single-variable representation of tree density

Negatives: Assumed spatial knowledge of NY, forces the comparison between borough (which by nautre means that income is segmented by boroughts), unclear whether red/green gradation of borough map is is within borough or total area. . . No legend determining intervals. . . 

To-do: 
(1) do a graph of distribution of income by borough. . . 
(2) do a map based on neighborhood. . . 

--Finding income data
--Finding neighborhood data

Tasks:
--Normalize by greenspace
--